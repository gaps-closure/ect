## Inputs

==WIP: this stuff will move around this section==

The GEDL is a JSON document specifying all the cross domain calls and their associated data including the arguments and return type. For function arguments, the directional assignment of that argument is indicated: input (a source argument, the function is reading in this value), output (a destination argument, the function is writing data to this argument), both (the argument is used as both an input and output argument in the function). This specification enables the RPC logic to auto-generate the required code to marshal the data accordingly.

The IDL is a text file with a set of C-style struct data type definitions, used to facilitate subsequent serialization and marshaling of data types. The IDL syntax is based on C; an IDL file contains one or more C struct datatypes. Two structs are generated for each TAG request and response pair, with the in arguments in the request and the out arguments in the response. Currently we support most primitive C types and fixed-size arrays of those types. The idl_generator script takes a gedl JSON and produces the idl.

For each struct in the IDL, codecs are generated to facilitate serialization to the remote enclave. The codecs consist of encode and decode functions for each of the structs, which handle byte order conversions between host and network byte order. In addition to the codecs, DFDL description of each serialized request/response is generated by the DFDL writer. The generated codecs are registered in the HAL daemon. The generated RPC code registers these codecs for use of the xdcomms send/recv functions. It includes a rpc_wrapper/handler for each function called cross domain.

The rpc_generator.py is used to generate the *_rpc.{c,h} for compilation. The rpc code automates cross domain function invocation and replaces calls to those functions with ones that additionally marshall and send the data across the network using the generated codecs and IDL.

The rpc generator takes as input: 1. Partitioned application code including name of main program, 2. CLE annotations for each individual function 3. The generated gedl 4. Input/output ZMQ uris 5. Base values for mux, sec, typ parameters 6. The cle user annotations for reliability parameters (retries, timeout and idempotence).

It produces C source and header files for CLE-annotated RPC code for each partition including the RPC wrapper and peer call handler. Additionally, a xdconf.ini is generated, which a separate script uses to configure HAL. The CLE-annotated RPC code contains the definitions for each TAG_ request/response pair. It also generates the input application code with the following modifications:

- It adds HAL init and RPC headers to main program
- It renames cross domain calls in original source from foo() to _rpc_foo() On the partition without the main, it will create a main program and a handler loop awaiting the RPC calls

Additionally, there are two IPC modes for the generated rpc code, which either can either generate singlethreaded or multithreaded rpc handlers. The multithreaded mode provides one RPC handler thread per cross domain function, while the singlethreaded mode has one global rpc handler for all cross domain calls.

DFDL is an extension of XSD which provides a way to describe binary formats and easily encode/decode from binary to an xml infoset. CLOSURE has the ability to create DFDL schemas for each cross domain request/response pair with use of the hal_autogen.

The hal_autoconfig.py script takes a xdconf.ini generated by the rpc generator and a devices.json and combines them to produce a HAL configuration.
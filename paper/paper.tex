\documentclass[conference,compsoc]{IEEEtran}
\usepackage{cite}

\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  \graphicspath{fig}
  \DeclareGraphicsExtensions{.pdf}
\else
  \usepackage[dvips]{graphicx}
  \graphicspath{fig}
  \DeclareGraphicsExtensions{.pdf}
\fi

\usepackage{listings}
\lstset{basicstyle=\footnotesize,
  columns=fullflexible
  }

\usepackage{amsthm}

\begin{document}

% paper title
\title{A Verified-by-Construction Approach to Building Security-Critical
Distributed Programs}

% author names and affiliations
\author{
    \IEEEauthorblockN{Maxwell Levatich}
    \IEEEauthorblockA{Department of Computer Science\\
    Columbia University\\
    Email: ml4553@columbia.edu}\\
    \IEEEauthorblockN{Michael Kaplan}
    \IEEEauthorblockA{Peraton Labs\\
    Email: mkaplan@peratonlabs.com}
    \and
    \IEEEauthorblockN{Stephen Edwards}
    \IEEEauthorblockA{Department of Computer Science\\
    Columbia University\\
    Email: sedwards@cs.columbia.edu}\\
    \IEEEauthorblockN{Robert Brotzman}
    \IEEEauthorblockA{Peraton Labs\\
    Email: robert.brotzman@peratonlabs.com}
    \and
    \IEEEauthorblockN{Rajesh Krishnan}
    \IEEEauthorblockA{Peraton Labs\\
    Email: rkrishnan@peratonlabs.com}\\\\
    \IEEEauthorblockN{Benjamin Flin}
    \IEEEauthorblockA{Peraton Labs\\
    Email: benjamin.flin@peratonlabs.com}
}

\maketitle

\begin{abstract}

(For now, just read what's written in Section 1)

\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}

Verifying distributed systems as they exist in the wild is a herculean effort.
The most interesting distributed systems and algorithms contain a number of
moving components (each with different goals), complex control flow, and
concurrency, all of which must be modeled in order to make whole-system security
guarantees. Furthermore, these systems are not usually static - networked
systems are being updated all the time, deprecating old proofs unless each new
update is re-verified. A favored approach for sidestepping this challenge is to
make these systems secure by construction, that is, to provide a method for
developers to build distributed systems and express their security properties at
an abstraction level. The distributed system is then generated automatically
from the design abstraction and is guaranteed to abide by the given security
properties.

An example of this interplay is a distributed system of hardware isolated,
mutually distrusting hosts passing data to each other over a network. Individual
hosts should leak as little data to each other as possible, so that if one host
is attacked, the entire system is not compromised. To that end, the developer
may write a formal specification describing the subset of data which can be
shared between each host and the approved code channels through which the data
must pass.

Tightly coupling the specification with the design and construction of
the system, however, is not enough to call it secure by construction; we
must formally verify that the system adheres to its specification. This presents
its own challenges.

    \begin{enumerate}

        \item{If we wait to verify the system until it is constructed, we have
              not avoided the system's ultimate complexity after all.}
        \item{If we verify the \textit{design} of the system, which is given at
              a higher level of abstraction that elides the implementation
              details, then we ignore the possibility that the
              \textit{generation} is somehow faulty and introduces security
              vulnerabilities.}

    \end{enumerate}

These difficulties suggest approaches which tackle the verification of both
distributed system design and generation. We present just such an approach,
tailored specifically for the example scenario described above of hardware
isolated mutually distrusting components.

\section{Overview}

    This section will summarize the different functions of the tool and its
    crucial contributions at a bird's eye view using a motivating example.

    \subsection{Motivating Example}

        If something like SecDesk is not sufficiently concise or motivating we
        may need something else here, but since the overview section is sort of
        a high-level, friendly summary, it should be guided all the way through
        by a motivating example.

    \subsection{The Serial Abstraction}

        Simple classes of distributed systems which serially pass control-flow
        between hosts and spin until control is given back to them, can be
        modeled as a single-threaded program running on a single machine.

        Discuss the limitations we accept and advantages we get from using this
        abstraction.

    \subsection{Security Labels}

        Introduce the notion of annotations in an existing program which convey
        security properties of program data. Mainly, in our case, the privacy of
        the data and the hosts and approved channels through which it can
        travel.

    \subsection{Determining a Partition}

        Discuss how the partition is determined from the given annotations:
        a constraint solver! Discuss the objective we want to minimize. Discuss
        how we turn the security labels into a wrapper type system on top of
        the program in order to propagate security constraints through data and
        control flow, and how that data and control flow is represented in the
        model (PDG).

    \subsection{Post-Partition Type Checking}

        See the beginning of the partition verification section.

\section{The Label Type System}

    We use SMT to allow an optimizing type system, which sits atop an
    existing programming language (C) that has its own type system. We ought to
    cite some type-system literature here to argue that an optimizing type
    system is interesting, and that it is uniquely relevant for our use case.

    \subsection{Formalization}

        Give a succinct specification of the CLE label type system in
        this section, with inference rules and such.

    \subsection{SMT-Backed Label Optimization}

        Type inference is upgraded to type \textit{optimization} with
        the help of a constraint solver.

\section{Partition Verification}

    The work of determining and propagating the type safety of the labels (and
    thus, the correctness of the security properties of the distributed system
    which they represent) is wasted if we cannot verify that those security
    properties actually make it into the generated code.

    We need to take the additional step of verifying the correct and compliant
    translation of the serial program abstraction into a concurrent distributed
    program.

    \subsection{Transferring Labels to the Partition}

        The complete set of inferred labels exists only in the serial
        abstraction. A mechanical transformation turns the serial program into
        a distributed, concurrent program performing the same function - we need
        a morphism between the instructions in these two programs in order
        to map the labels onto the distributed program.

        Discuss how we construct the definition and instruction mapping. ECT
        machinery.

        Discuss how we are sure this label transfer doesn't introduce any
        bugs (proof certificate provided by the ECT, either through manual
        constraint programming, LiquidHaskell, Coq, etc).

    \subsection{A Type Check Verifies the Partition}

        With the labels now in the partition, type checking the labeled,
        partitioned code tells us whether anything went wrong in the translation
        from serial program to concurrent, distributed program.

        How can we be sure the type check is correct and does not give false
        positives? Answer: It's bundled into the ECT, so it benefits from the
        same proof certificate.

\section{Evaluation}

    Use our existing test cases, like XDCC and SecDesk, plus hopefully
    some more, to evaluate the speed and scalability of the tool.

    We will also want some non-trivially generated \textit{incorrect} examples
    to show that the tool is effective at catching errors.

\section{Related Work}

    Work-in-progress summary of existing state-of-the art in the verified
    program security space.

    pg.4) SVA, KCoFI, CPI, Verve. Apparently one of these verifies "control flow
    integrity". I should look into that, sounds relevant to us.

    pg.4) "Formal methods also provide secure-by-construction methods for
    building systems, including program synthesis" Can partitioning be cast as
    a secure-by-construction method for building a system? If the partitioning
    procedure is verified?

    pg.5) "Differential privacy provides a strong compositional formal
    notion of privacy". Definitely investigate

    Hard for us to target theoretical rigor, so instead target "transition to
    practice", "interoperability", and good "abstractions"

    pg.18) Verifying S3? How was this done?

    pg.19) Distributed systems should be verified incrementally. Ours is a
    distributed system, and we tackle one piece of it. \cite{chong2016report}

    (see my notebook for other summaries, to be transcribed here)

\section{Conclusion}

    Summarize contributions. Acknowledgements.





\let\thefootnote\relax\footnotetext{This work was sponsored by DARPA under the
GAPS project.}
\bibliographystyle{IEEEtran}
\bibliography{paper}
\end{document}
